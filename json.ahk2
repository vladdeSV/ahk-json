#Requires AutoHotkey v2.0-a134

class JSON {
    /**
     * @param string data JSON data
     * 
     * @return Map|Array
     */
    static Parse(data) {
        json := Map()

        return json
    }

    /**
     * @param Map|Array variable
     * 
     * @return string
     */
    static Stringify(variable) {
        return ''
    }

    /**
     * Custom null implementation
     *
     * @returns Object Read-only static variable
     */
    static Null {
        get {
            static null := {}
            return null
        }
    }
}

/**
 * @see https://notes.eatonphil.com/writing-a-simple-json-parser.html
 * @return Array JSON tokens
 */
Lex(data) {
    ; placeholder value when lexing part does not match
    static None := {}

    LexString(str) {
        jsonString := ''
    
        if (SubStr(str, 1, 1) != '"') {
            return [None, str]
        }
        ; we are now inside a string. continue until we hit a " that is not escaped
    
        ; remove first character (the quote)
        str := SubStr(str, 2)
        isEscaped := false
    
        for (character in StrSplit(str)) {
            if (character == '"' && !isEscaped) {
                return ['"' . jsonString . '"', SubStr(str, StrLen(jsonString) + 2)]
            }
    
            if (character == '\' && !isEscaped) {
                isEscaped := true
                continue
            }
    
            isEscaped := false
    
            jsonString := jsonString . character
        }
    
        throw Error('Expected end-of-string quote', -1)
    }

    LexBoolean(str) {
        if (SubStr(str, 1, 4) == 'true') {
            return ['true', SubStr(str, 5)]
        }
    
        
        if (SubStr(str, 1, 5) == 'false') {
            return ['false', SubStr(str, 6)]
        }
    
        return [None, str]
    }

    LexNull(str) {
        if (SubStr(str, 1, 4) == 'null') {
            return ['null', SubStr(str, 5)]
        }

        return [None, str]
    }

    LexNumber(str) {
        jsonNumber := ''
    
        numbers := '0123456789-eE.'
    
        for (character in StrSplit(str)){
            if (!InStr(numbers, character)) {
                break
            }
    
            jsonNumber := jsonNumber character
        }
    
        rest := SubStr(str, StrLen(jsonNumber) + 1)
    
        if (StrLen(jsonNumber) == 0) {
            return [None, str]
        }
    
        return [jsonNumber, rest]
    }
    
    tokens := []

    while (StrLen(data)) {
        ; is a string
        jsonString := LexString(data)
        if (jsonString[1] != None) {
            tokens.Push(jsonString[1])
            data := jsonString[2]
            continue
        }

        ; is a boolean
        jsonBoolean := LexBoolean(data)
        if (jsonBoolean[1] != None) {
            tokens.Push(jsonBoolean[1])
            data := jsonBoolean[2]
            continue
        }

        ; is null
        jsonNull := LexNull(data)
        if (jsonNull[1] != None) {
            tokens.Push(jsonNull[1])
            data := jsonNull[2]
            continue
        }

        ; is number
        jsonNumber := LexNumber(data)
        if (jsonNumber[1] != None) {
            tokens.Push(jsonNumber[1])
            data := jsonNumber[2]
            continue
        }

        ; is whitespace
        if (InStr(' `t`n', SubStr(data, 1, 1))) {
            data := SubStr(data, 2)
            continue
        }
        
        ; is json syntax characters
        if (InStr('{}()[]:,', SubStr(data, 1, 1))) {
            tokens.Push(SubStr(data, 1, 1))
            data := SubStr(data, 2)
            continue
        }
        
        throw Error('Unexpected character: ' SubStr(data, 1, 1), -2)
    }

    return tokens
}

SubArr(arr, from, length := 0) {
    ret := arr.Clone()
    ret.RemoveAt(1, from - 1)

    if (length > 0) {
        ret.RemoveAt(length + 1, ret.length - length)
    }
    
    return ret
}
