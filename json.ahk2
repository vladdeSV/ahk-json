#Requires AutoHotkey v2.0-a134

class JSON {
    /**
     * @param string data JSON data
     * 
     * @return Map|Array
     */
    static Parse(data) {
        json := Map()

        return json
    }

    /**
     * @param Map|Array variable
     * 
     * @return string
     */
    static Stringify(variable) {
        return ''
    }

    /**
     * Custom null implementation
     *
     * @returns Object Read-only static variable
     */
    static Null {
        get {
            static null := {}
            return null
        }
    }
}

/**
 * @see https://notes.eatonphil.com/writing-a-simple-json-parser.html
 * @return Array JSON tokens
 */
Lex(data) {
    ; placeholder value when lexing part does not match
    static None := {}

    LexString(str) {
        jsonString := ''
    
        if (SubStr(str, 1, 1) != '"') {
            return [None, str]
        }
        ; we are now inside a string. continue until we hit a " that is not escaped
    
        ; remove first character (the quote)
        str := SubStr(str, 2)
        isEscaped := false
    
        for (character in StrSplit(str)) {
            if (character == '"' && !isEscaped) {
                return ['"' . jsonString . '"', SubStr(str, StrLen(jsonString) + 2)]
            }
    
            if (character == '\' && !isEscaped) {
                isEscaped := true
                continue
            }
    
            isEscaped := false
    
            jsonString := jsonString . character
        }
    
        throw Error('Expected end-of-string quote', -1)
    }

    LexBoolean(str) {
        if (SubStr(str, 1, 4) == 'true') {
            return ['true', SubStr(str, 5)]
        }
    
        
        if (SubStr(str, 1, 5) == 'false') {
            return ['false', SubStr(str, 6)]
        }
    
        return [None, str]
    }

    LexNull(str) {
        if (SubStr(str, 1, 4) == 'null') {
            return ['null', SubStr(str, 5)]
        }

        return [None, str]
    }

    LexNumber(str) {
        jsonNumber := ''
    
        numbers := '0123456789-eE.'
    
        for (character in StrSplit(str)){
            if (!InStr(numbers, character)) {
                break
            }
    
            jsonNumber := jsonNumber character
        }
    
        rest := SubStr(str, StrLen(jsonNumber) + 1)
    
        if (StrLen(jsonNumber) == 0) {
            return [None, str]
        }
    
        return [jsonNumber, rest]
    }
    
    tokens := []

    while (StrLen(data)) {
        ; is a string
        jsonString := LexString(data)
        if (jsonString[1] != None) {
            tokens.Push(jsonString[1])
            data := jsonString[2]
            continue
        }

        ; is a boolean
        jsonBoolean := LexBoolean(data)
        if (jsonBoolean[1] != None) {
            tokens.Push(jsonBoolean[1])
            data := jsonBoolean[2]
            continue
        }

        ; is null
        jsonNull := LexNull(data)
        if (jsonNull[1] != None) {
            tokens.Push(jsonNull[1])
            data := jsonNull[2]
            continue
        }

        ; is number
        jsonNumber := LexNumber(data)
        if (jsonNumber[1] != None) {
            tokens.Push(jsonNumber[1])
            data := jsonNumber[2]
            continue
        }

        ; is whitespace
        if (InStr(' `t`n', SubStr(data, 1, 1))) {
            data := SubStr(data, 2)
            continue
        }
        
        ; is json syntax characters
        if (InStr('{}()[]:,', SubStr(data, 1, 1))) {
            tokens.Push(SubStr(data, 1, 1))
            data := SubStr(data, 2)
            continue
        }
        
        throw Error('Unexpected character: ' SubStr(data, 1, 1), -2)
    }

    return tokens
}

SubArr(arr, from, length := 0) {
    ret := arr.Clone()
    ret.RemoveAt(1, from - 1)

    if (length > 0) {
        ret.RemoveAt(length + 1, ret.length - length)
    }
    
    return ret
}

/**
 * @return [Array, Array]
 */
ParseArray(tokens) {
    json_array := []

    token := tokens[1]
    tokenKind := ParseTokenKind(token)

    if (tokenKind == END_ARRAY) {
        return [json_array, SubArr(tokens, 2)]
    }

    while (true) {
        foo := Parse(tokens)
        json_ := foo[1]
        tokens := foo[2]

        json_array.Push(json_)

        token := tokens[1]
        tokenKind := ParseTokenKind(token)

        if (tokenKind == END_ARRAY) {
            return [json_array, SubArr(tokens, 2)]
        } else if (tokenKind !== COMMA) {
            throw Error('Expected comma after value in array')
        } else {
            tokens := SubArr(tokens, 2)
        }
    }
}

/**
 * @return [Map, Array]
 */
ParseObject(tokens) {
    json_object := Map()

    token := tokens[1]
    tokenKind := ParseTokenKind(token)
    
    if (token == END_OBJECT) {
        return [json_object, SubArr(tokens, 2)]
    }

    while (true) {
        json_key := tokens[1]
        tokenKind := ParseTokenKind(token)

        if (tokenKind == STRING_) {
            tokens := SubArr(tokens, 2)
        } else {
            throw Error('Expected string key, got ' tokenKind)
        }

        if (ParseTokenKind(tokens[0]) !== COLON) {
            throw Error('Expected colon after key in object, got ' tokenKind)
        }

        foo := Parse(SubArr(tokens, 2))
        json_value := foo[1]
        tokens := foo[2]

        json_object[json_key] := json_value

        token := tokens[0]
        tokenKind := ParseTokenKind(token)

        if (tokenKind == END_OBJECT) {
            return [json_object, SubArr(tokens, 2)]
        } else if (tokenKind !== COMMA) {
            throw Error()
        }

        tokens := SubArr(tokens, 2)
    }
}

/**
 * @return [Any, Array]
 */
Parse(tokens) {
    token := tokens[1]
    tokenKind := ParseTokenKind(token)

    switch (tokenKind) {
        case BEGIN_ARRAY:
            return ParseArray(SubArr(tokens, 2))
        case BEGIN_OBJECT:
            return ParseObject(SubArr(tokens, 2))
        default:
            return [token, SubArr(tokens, 2)]
    }
}

BEGIN_OBJECT := 'BEGIN_OBJECT'
END_OBJECT := 'END_OBJECT'
BEGIN_ARRAY := 'BEGIN_ARRAY'
END_ARRAY := 'END_ARRAY'
COLON := 'COLON'
COMMA := 'COMMA'
STRING_ := 'STRING'
NUMBER_ := 'NUMBER'
NULL := 'NULL'
BOOLEAN := 'BOOLEAN'

/**
 * @return string
 */
ParseTokenKind(token) {
    switch token {
        case '{':
            return BEGIN_OBJECT
        case '}':
            return END_OBJECT
        case '[':
            return BEGIN_ARRAY
        case ']':
            return END_ARRAY
        case ':':
            return COLON
        case ',':
            return COMMA
        case 'null':
            return NULL
        case 'true':
        case 'false':
            return BOOLEAN
        default:
            if (RegExMatch(token, '".*"')) {
                return STRING_
            }
            
            if (RegExMatch(token, '-?\d+(\.\d+)?([+-]?e\d+)?')) {
                return NUMBER_
            }

            throw Error('Unknown token `'' token '`'')
    }
}
